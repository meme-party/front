/* tslint:disable */
/* eslint-disable */
/**
 * Dionysus API
 * Meme Project
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: dev.shinkeonkim@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from "../runtime"
import type {
  ApiV1MemesBookmarkIdsRetrieve200Response,
  Bookmark,
  Bookmarking,
  BookmarkingSyncRequest,
  JWT,
  KakaoAuthResponse,
  Meme,
  PaginatedBookmarkList,
  PaginatedBookmarkingList,
  PaginatedMemeList,
  PaginatedTagList,
  RestAuthDetail,
  SocialAccount,
  SocialLogin,
  Tag,
  TokenRefresh,
  TokenVerify,
  UserDetail
} from "../models/index"
import {
  ApiV1MemesBookmarkIdsRetrieve200ResponseFromJSON,
  ApiV1MemesBookmarkIdsRetrieve200ResponseToJSON,
  BookmarkFromJSON,
  BookmarkToJSON,
  BookmarkingFromJSON,
  BookmarkingToJSON,
  BookmarkingSyncRequestFromJSON,
  BookmarkingSyncRequestToJSON,
  JWTFromJSON,
  JWTToJSON,
  KakaoAuthResponseFromJSON,
  KakaoAuthResponseToJSON,
  MemeFromJSON,
  MemeToJSON,
  PaginatedBookmarkListFromJSON,
  PaginatedBookmarkListToJSON,
  PaginatedBookmarkingListFromJSON,
  PaginatedBookmarkingListToJSON,
  PaginatedMemeListFromJSON,
  PaginatedMemeListToJSON,
  PaginatedTagListFromJSON,
  PaginatedTagListToJSON,
  RestAuthDetailFromJSON,
  RestAuthDetailToJSON,
  SocialAccountFromJSON,
  SocialAccountToJSON,
  SocialLoginFromJSON,
  SocialLoginToJSON,
  TagFromJSON,
  TagToJSON,
  TokenRefreshFromJSON,
  TokenRefreshToJSON,
  TokenVerifyFromJSON,
  TokenVerifyToJSON,
  UserDetailFromJSON,
  UserDetailToJSON
} from "../models/index"

export interface ApiV1AccountsKakaoLoginCallbackRetrieveRequest {
  code: string
  redirectUri?: string
}

export interface ApiV1AccountsKakaoLoginFinishCreateRequest {
  accessToken?: string
  code?: string
  idToken?: string
}

export interface ApiV1AccountsLoginCreateRequest {
  password: string
  username?: string
  email?: string
}

export interface ApiV1AccountsPasswordChangeCreateRequest {
  newPassword1: string
  newPassword2: string
}

export interface ApiV1AccountsPasswordResetConfirmCreateRequest {
  newPassword1: string
  newPassword2: string
  uid: string
  token: string
}

export interface ApiV1AccountsPasswordResetCreateRequest {
  email: string
}

export interface ApiV1AccountsTokenRefreshCreateRequest {
  access: string
  refresh: string
}

export interface ApiV1AccountsTokenVerifyCreateRequest {
  token: string
}

export interface ApiV1AccountsUserPartialUpdateRequest {
  pk?: number
  email?: string
  username?: string
  socialAccount?: Array<SocialAccount>
}

export interface ApiV1AccountsUserUpdateRequest {
  pk: number
  email: string
  socialAccount: Array<SocialAccount>
  username?: string
}

export interface ApiV1BookmarksBookmarkingsListRequest {
  bookmarkPk: number
  ordering?: string
  page?: number
  perPage?: number
  search?: string
}

export interface ApiV1BookmarksBookmarkingsRetrieveRequest {
  bookmarkPk: number
  id: number
}

export interface ApiV1BookmarksCreateRequest {
  id: number
  title: string
  bookmarkingsCount: number
  createdAt: Date
  updatedAt: Date
}

export interface ApiV1BookmarksDestroyRequest {
  id: number
}

export interface ApiV1BookmarksListRequest {
  ordering?: string
  page?: number
  perPage?: number
  search?: string
}

export interface ApiV1BookmarksPartialUpdateRequest {
  id: number
  id2?: number
  title?: string
  bookmarkingsCount?: number
  createdAt?: Date
  updatedAt?: Date
}

export interface ApiV1BookmarksRetrieveRequest {
  id: number
}

export interface ApiV1BookmarksUpdateRequest {
  id: number
  id2: number
  title: string
  bookmarkingsCount: number
  createdAt: Date
  updatedAt: Date
}

export interface ApiV1MemesBookmarkIdsRetrieveRequest {
  memeId: number
}

export interface ApiV1MemesListRequest {
  ordering?: string
  page?: number
  perPage?: number
  search?: string
  tagsCategoryName?: string
  type?: ApiV1MemesListTypeEnum
}

export interface ApiV1MemesRelatedListRequest {
  memeId: number
  count?: number
}

export interface ApiV1MemesRetrieveRequest {
  id: number
}

export interface ApiV1TagsByFirstLetterListRequest {
  count?: number
  orderBy?: ApiV1TagsByFirstLetterListOrderByEnum
}

export interface ApiV1TagsFavoriteListRequest {
  ordering?: string
  page?: number
  perPage?: number
  search?: string
}

export interface ApiV1TagsListRequest {
  category?: number
  firstLetter?: string
  ordering?: string
  page?: number
  perPage?: number
  search?: string
}

export interface BookmarkingDeleteRequest {
  bookmarkingId: number
}

export interface BookmarkingSyncOperationRequest {
  bookmarkingSyncRequest?: BookmarkingSyncRequest
}

/**
 *
 */
export class ApiApi extends runtime.BaseAPI {
  /**
   * 카카오 인증 후 받은 인가 코드(code)를 이용해 액세스 토큰을 요청하고, 회원가입 또는 로그인 처리를 합니다.
   * Kakao OAuth Callback
   */
  async apiV1AccountsKakaoLoginCallbackRetrieveRaw(
    requestParameters: ApiV1AccountsKakaoLoginCallbackRetrieveRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<KakaoAuthResponse>> {
    if (requestParameters["code"] == null) {
      throw new runtime.RequiredError(
        "code",
        'Required parameter "code" was null or undefined when calling apiV1AccountsKakaoLoginCallbackRetrieve().'
      )
    }

    const queryParameters: any = {}

    if (requestParameters["code"] != null) {
      queryParameters["code"] = requestParameters["code"]
    }

    if (requestParameters["redirectUri"] != null) {
      queryParameters["redirect_uri"] = requestParameters["redirectUri"]
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request(
      {
        path: `/api/v1/accounts/kakao/login/callback/`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => KakaoAuthResponseFromJSON(jsonValue))
  }

  /**
   * 카카오 인증 후 받은 인가 코드(code)를 이용해 액세스 토큰을 요청하고, 회원가입 또는 로그인 처리를 합니다.
   * Kakao OAuth Callback
   */
  async apiV1AccountsKakaoLoginCallbackRetrieve(
    requestParameters: ApiV1AccountsKakaoLoginCallbackRetrieveRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<KakaoAuthResponse> {
    const response = await this.apiV1AccountsKakaoLoginCallbackRetrieveRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * class used for social authentications example usage for facebook with access_token ------------- from allauth.socialaccount.providers.facebook.views import FacebookOAuth2Adapter  class FacebookLogin(SocialLoginView):     adapter_class = FacebookOAuth2Adapter -------------  example usage for facebook with code  ------------- from allauth.socialaccount.providers.facebook.views import FacebookOAuth2Adapter from allauth.socialaccount.providers.oauth2.client import OAuth2Client  class FacebookLogin(SocialLoginView):     adapter_class = FacebookOAuth2Adapter     client_class = OAuth2Client     callback_url = \'localhost:8000\' -------------
   */
  async apiV1AccountsKakaoLoginFinishCreateRaw(
    requestParameters: ApiV1AccountsKakaoLoginFinishCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<SocialLogin>> {
    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const consumes: runtime.Consume[] = [
      { contentType: "application/x-www-form-urlencoded" },
      { contentType: "multipart/form-data" },
      { contentType: "application/json" }
    ]
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes)

    let formParams: { append(param: string, value: any): any }
    let useForm = false
    if (useForm) {
      formParams = new FormData()
    } else {
      formParams = new URLSearchParams()
    }

    if (requestParameters["accessToken"] != null) {
      formParams.append("access_token", requestParameters["accessToken"] as any)
    }

    if (requestParameters["code"] != null) {
      formParams.append("code", requestParameters["code"] as any)
    }

    if (requestParameters["idToken"] != null) {
      formParams.append("id_token", requestParameters["idToken"] as any)
    }

    const response = await this.request(
      {
        path: `/api/v1/accounts/kakao/login/finish/`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: formParams
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => SocialLoginFromJSON(jsonValue))
  }

  /**
   * class used for social authentications example usage for facebook with access_token ------------- from allauth.socialaccount.providers.facebook.views import FacebookOAuth2Adapter  class FacebookLogin(SocialLoginView):     adapter_class = FacebookOAuth2Adapter -------------  example usage for facebook with code  ------------- from allauth.socialaccount.providers.facebook.views import FacebookOAuth2Adapter from allauth.socialaccount.providers.oauth2.client import OAuth2Client  class FacebookLogin(SocialLoginView):     adapter_class = FacebookOAuth2Adapter     client_class = OAuth2Client     callback_url = \'localhost:8000\' -------------
   */
  async apiV1AccountsKakaoLoginFinishCreate(
    requestParameters: ApiV1AccountsKakaoLoginFinishCreateRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<SocialLogin> {
    const response = await this.apiV1AccountsKakaoLoginFinishCreateRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Check the credentials and return the REST Token if the credentials are valid and authenticated. Calls Django Auth login method to register User ID in Django session framework  Accept the following POST parameters: username, password Return the REST Framework Token Object\'s key.
   */
  async apiV1AccountsLoginCreateRaw(
    requestParameters: ApiV1AccountsLoginCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<JWT>> {
    if (requestParameters["password"] == null) {
      throw new runtime.RequiredError(
        "password",
        'Required parameter "password" was null or undefined when calling apiV1AccountsLoginCreate().'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const consumes: runtime.Consume[] = [
      { contentType: "application/x-www-form-urlencoded" },
      { contentType: "multipart/form-data" },
      { contentType: "application/json" }
    ]
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes)

    let formParams: { append(param: string, value: any): any }
    let useForm = false
    if (useForm) {
      formParams = new FormData()
    } else {
      formParams = new URLSearchParams()
    }

    if (requestParameters["username"] != null) {
      formParams.append("username", requestParameters["username"] as any)
    }

    if (requestParameters["email"] != null) {
      formParams.append("email", requestParameters["email"] as any)
    }

    if (requestParameters["password"] != null) {
      formParams.append("password", requestParameters["password"] as any)
    }

    const response = await this.request(
      {
        path: `/api/v1/accounts/login/`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: formParams
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => JWTFromJSON(jsonValue))
  }

  /**
   * Check the credentials and return the REST Token if the credentials are valid and authenticated. Calls Django Auth login method to register User ID in Django session framework  Accept the following POST parameters: username, password Return the REST Framework Token Object\'s key.
   */
  async apiV1AccountsLoginCreate(
    requestParameters: ApiV1AccountsLoginCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<JWT> {
    const response = await this.apiV1AccountsLoginCreateRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Calls Django logout method and delete the Token object assigned to the current User object.  Accepts/Returns nothing.
   */
  async apiV1AccountsLogoutCreateRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<RestAuthDetail>> {
    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request(
      {
        path: `/api/v1/accounts/logout/`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => RestAuthDetailFromJSON(jsonValue))
  }

  /**
   * Calls Django logout method and delete the Token object assigned to the current User object.  Accepts/Returns nothing.
   */
  async apiV1AccountsLogoutCreate(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestAuthDetail> {
    const response = await this.apiV1AccountsLogoutCreateRaw(initOverrides)
    return await response.value()
  }

  /**
   * Calls Django Auth SetPasswordForm save method.  Accepts the following POST parameters: new_password1, new_password2 Returns the success/fail message.
   */
  async apiV1AccountsPasswordChangeCreateRaw(
    requestParameters: ApiV1AccountsPasswordChangeCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<RestAuthDetail>> {
    if (requestParameters["newPassword1"] == null) {
      throw new runtime.RequiredError(
        "newPassword1",
        'Required parameter "newPassword1" was null or undefined when calling apiV1AccountsPasswordChangeCreate().'
      )
    }

    if (requestParameters["newPassword2"] == null) {
      throw new runtime.RequiredError(
        "newPassword2",
        'Required parameter "newPassword2" was null or undefined when calling apiV1AccountsPasswordChangeCreate().'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const consumes: runtime.Consume[] = [
      { contentType: "application/x-www-form-urlencoded" },
      { contentType: "multipart/form-data" },
      { contentType: "application/json" }
    ]
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes)

    let formParams: { append(param: string, value: any): any }
    let useForm = false
    if (useForm) {
      formParams = new FormData()
    } else {
      formParams = new URLSearchParams()
    }

    if (requestParameters["newPassword1"] != null) {
      formParams.append("new_password1", requestParameters["newPassword1"] as any)
    }

    if (requestParameters["newPassword2"] != null) {
      formParams.append("new_password2", requestParameters["newPassword2"] as any)
    }

    const response = await this.request(
      {
        path: `/api/v1/accounts/password/change/`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: formParams
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => RestAuthDetailFromJSON(jsonValue))
  }

  /**
   * Calls Django Auth SetPasswordForm save method.  Accepts the following POST parameters: new_password1, new_password2 Returns the success/fail message.
   */
  async apiV1AccountsPasswordChangeCreate(
    requestParameters: ApiV1AccountsPasswordChangeCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<RestAuthDetail> {
    const response = await this.apiV1AccountsPasswordChangeCreateRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Password reset e-mail link is confirmed, therefore this resets the user\'s password.  Accepts the following POST parameters: token, uid,     new_password1, new_password2 Returns the success/fail message.
   */
  async apiV1AccountsPasswordResetConfirmCreateRaw(
    requestParameters: ApiV1AccountsPasswordResetConfirmCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<RestAuthDetail>> {
    if (requestParameters["newPassword1"] == null) {
      throw new runtime.RequiredError(
        "newPassword1",
        'Required parameter "newPassword1" was null or undefined when calling apiV1AccountsPasswordResetConfirmCreate().'
      )
    }

    if (requestParameters["newPassword2"] == null) {
      throw new runtime.RequiredError(
        "newPassword2",
        'Required parameter "newPassword2" was null or undefined when calling apiV1AccountsPasswordResetConfirmCreate().'
      )
    }

    if (requestParameters["uid"] == null) {
      throw new runtime.RequiredError(
        "uid",
        'Required parameter "uid" was null or undefined when calling apiV1AccountsPasswordResetConfirmCreate().'
      )
    }

    if (requestParameters["token"] == null) {
      throw new runtime.RequiredError(
        "token",
        'Required parameter "token" was null or undefined when calling apiV1AccountsPasswordResetConfirmCreate().'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const consumes: runtime.Consume[] = [
      { contentType: "application/x-www-form-urlencoded" },
      { contentType: "multipart/form-data" },
      { contentType: "application/json" }
    ]
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes)

    let formParams: { append(param: string, value: any): any }
    let useForm = false
    if (useForm) {
      formParams = new FormData()
    } else {
      formParams = new URLSearchParams()
    }

    if (requestParameters["newPassword1"] != null) {
      formParams.append("new_password1", requestParameters["newPassword1"] as any)
    }

    if (requestParameters["newPassword2"] != null) {
      formParams.append("new_password2", requestParameters["newPassword2"] as any)
    }

    if (requestParameters["uid"] != null) {
      formParams.append("uid", requestParameters["uid"] as any)
    }

    if (requestParameters["token"] != null) {
      formParams.append("token", requestParameters["token"] as any)
    }

    const response = await this.request(
      {
        path: `/api/v1/accounts/password/reset/confirm/`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: formParams
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => RestAuthDetailFromJSON(jsonValue))
  }

  /**
   * Password reset e-mail link is confirmed, therefore this resets the user\'s password.  Accepts the following POST parameters: token, uid,     new_password1, new_password2 Returns the success/fail message.
   */
  async apiV1AccountsPasswordResetConfirmCreate(
    requestParameters: ApiV1AccountsPasswordResetConfirmCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<RestAuthDetail> {
    const response = await this.apiV1AccountsPasswordResetConfirmCreateRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Calls Django Auth PasswordResetForm save method.  Accepts the following POST parameters: email Returns the success/fail message.
   */
  async apiV1AccountsPasswordResetCreateRaw(
    requestParameters: ApiV1AccountsPasswordResetCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<RestAuthDetail>> {
    if (requestParameters["email"] == null) {
      throw new runtime.RequiredError(
        "email",
        'Required parameter "email" was null or undefined when calling apiV1AccountsPasswordResetCreate().'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const consumes: runtime.Consume[] = [
      { contentType: "application/x-www-form-urlencoded" },
      { contentType: "multipart/form-data" },
      { contentType: "application/json" }
    ]
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes)

    let formParams: { append(param: string, value: any): any }
    let useForm = false
    if (useForm) {
      formParams = new FormData()
    } else {
      formParams = new URLSearchParams()
    }

    if (requestParameters["email"] != null) {
      formParams.append("email", requestParameters["email"] as any)
    }

    const response = await this.request(
      {
        path: `/api/v1/accounts/password/reset/`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: formParams
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => RestAuthDetailFromJSON(jsonValue))
  }

  /**
   * Calls Django Auth PasswordResetForm save method.  Accepts the following POST parameters: email Returns the success/fail message.
   */
  async apiV1AccountsPasswordResetCreate(
    requestParameters: ApiV1AccountsPasswordResetCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<RestAuthDetail> {
    const response = await this.apiV1AccountsPasswordResetCreateRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
   */
  async apiV1AccountsTokenRefreshCreateRaw(
    requestParameters: ApiV1AccountsTokenRefreshCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<TokenRefresh>> {
    if (requestParameters["access"] == null) {
      throw new runtime.RequiredError(
        "access",
        'Required parameter "access" was null or undefined when calling apiV1AccountsTokenRefreshCreate().'
      )
    }

    if (requestParameters["refresh"] == null) {
      throw new runtime.RequiredError(
        "refresh",
        'Required parameter "refresh" was null or undefined when calling apiV1AccountsTokenRefreshCreate().'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    const consumes: runtime.Consume[] = [
      { contentType: "application/x-www-form-urlencoded" },
      { contentType: "multipart/form-data" },
      { contentType: "application/json" }
    ]
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes)

    let formParams: { append(param: string, value: any): any }
    let useForm = false
    if (useForm) {
      formParams = new FormData()
    } else {
      formParams = new URLSearchParams()
    }

    if (requestParameters["access"] != null) {
      formParams.append("access", requestParameters["access"] as any)
    }

    if (requestParameters["refresh"] != null) {
      formParams.append("refresh", requestParameters["refresh"] as any)
    }

    const response = await this.request(
      {
        path: `/api/v1/accounts/token/refresh/`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: formParams
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => TokenRefreshFromJSON(jsonValue))
  }

  /**
   * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
   */
  async apiV1AccountsTokenRefreshCreate(
    requestParameters: ApiV1AccountsTokenRefreshCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<TokenRefresh> {
    const response = await this.apiV1AccountsTokenRefreshCreateRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
   */
  async apiV1AccountsTokenVerifyCreateRaw(
    requestParameters: ApiV1AccountsTokenVerifyCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<TokenVerify>> {
    if (requestParameters["token"] == null) {
      throw new runtime.RequiredError(
        "token",
        'Required parameter "token" was null or undefined when calling apiV1AccountsTokenVerifyCreate().'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    const consumes: runtime.Consume[] = [
      { contentType: "application/x-www-form-urlencoded" },
      { contentType: "multipart/form-data" },
      { contentType: "application/json" }
    ]
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes)

    let formParams: { append(param: string, value: any): any }
    let useForm = false
    if (useForm) {
      formParams = new FormData()
    } else {
      formParams = new URLSearchParams()
    }

    if (requestParameters["token"] != null) {
      formParams.append("token", requestParameters["token"] as any)
    }

    const response = await this.request(
      {
        path: `/api/v1/accounts/token/verify/`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: formParams
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => TokenVerifyFromJSON(jsonValue))
  }

  /**
   * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
   */
  async apiV1AccountsTokenVerifyCreate(
    requestParameters: ApiV1AccountsTokenVerifyCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<TokenVerify> {
    const response = await this.apiV1AccountsTokenVerifyCreateRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
   */
  async apiV1AccountsUserPartialUpdateRaw(
    requestParameters: ApiV1AccountsUserPartialUpdateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<UserDetail>> {
    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const consumes: runtime.Consume[] = [
      { contentType: "application/x-www-form-urlencoded" },
      { contentType: "multipart/form-data" },
      { contentType: "application/json" }
    ]
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes)

    let formParams: { append(param: string, value: any): any }
    let useForm = false
    if (useForm) {
      formParams = new FormData()
    } else {
      formParams = new URLSearchParams()
    }

    if (requestParameters["pk"] != null) {
      formParams.append("pk", requestParameters["pk"] as any)
    }

    if (requestParameters["email"] != null) {
      formParams.append("email", requestParameters["email"] as any)
    }

    if (requestParameters["username"] != null) {
      formParams.append("username", requestParameters["username"] as any)
    }

    if (requestParameters["socialAccount"] != null) {
      formParams.append("social_account", requestParameters["socialAccount"]!.join(runtime.COLLECTION_FORMATS["csv"]))
    }

    const response = await this.request(
      {
        path: `/api/v1/accounts/user/`,
        method: "PATCH",
        headers: headerParameters,
        query: queryParameters,
        body: formParams
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => UserDetailFromJSON(jsonValue))
  }

  /**
   * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
   */
  async apiV1AccountsUserPartialUpdate(
    requestParameters: ApiV1AccountsUserPartialUpdateRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<UserDetail> {
    const response = await this.apiV1AccountsUserPartialUpdateRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
   */
  async apiV1AccountsUserRetrieveRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<UserDetail>> {
    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request(
      {
        path: `/api/v1/accounts/user/`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => UserDetailFromJSON(jsonValue))
  }

  /**
   * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
   */
  async apiV1AccountsUserRetrieve(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserDetail> {
    const response = await this.apiV1AccountsUserRetrieveRaw(initOverrides)
    return await response.value()
  }

  /**
   * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
   */
  async apiV1AccountsUserUpdateRaw(
    requestParameters: ApiV1AccountsUserUpdateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<UserDetail>> {
    if (requestParameters["pk"] == null) {
      throw new runtime.RequiredError(
        "pk",
        'Required parameter "pk" was null or undefined when calling apiV1AccountsUserUpdate().'
      )
    }

    if (requestParameters["email"] == null) {
      throw new runtime.RequiredError(
        "email",
        'Required parameter "email" was null or undefined when calling apiV1AccountsUserUpdate().'
      )
    }

    if (requestParameters["socialAccount"] == null) {
      throw new runtime.RequiredError(
        "socialAccount",
        'Required parameter "socialAccount" was null or undefined when calling apiV1AccountsUserUpdate().'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const consumes: runtime.Consume[] = [
      { contentType: "application/x-www-form-urlencoded" },
      { contentType: "multipart/form-data" },
      { contentType: "application/json" }
    ]
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes)

    let formParams: { append(param: string, value: any): any }
    let useForm = false
    if (useForm) {
      formParams = new FormData()
    } else {
      formParams = new URLSearchParams()
    }

    if (requestParameters["pk"] != null) {
      formParams.append("pk", requestParameters["pk"] as any)
    }

    if (requestParameters["email"] != null) {
      formParams.append("email", requestParameters["email"] as any)
    }

    if (requestParameters["username"] != null) {
      formParams.append("username", requestParameters["username"] as any)
    }

    if (requestParameters["socialAccount"] != null) {
      formParams.append("social_account", requestParameters["socialAccount"]!.join(runtime.COLLECTION_FORMATS["csv"]))
    }

    const response = await this.request(
      {
        path: `/api/v1/accounts/user/`,
        method: "PUT",
        headers: headerParameters,
        query: queryParameters,
        body: formParams
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => UserDetailFromJSON(jsonValue))
  }

  /**
   * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
   */
  async apiV1AccountsUserUpdate(
    requestParameters: ApiV1AccountsUserUpdateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<UserDetail> {
    const response = await this.apiV1AccountsUserUpdateRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   */
  async apiV1BookmarksBookmarkingsListRaw(
    requestParameters: ApiV1BookmarksBookmarkingsListRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<PaginatedBookmarkingList>> {
    if (requestParameters["bookmarkPk"] == null) {
      throw new runtime.RequiredError(
        "bookmarkPk",
        'Required parameter "bookmarkPk" was null or undefined when calling apiV1BookmarksBookmarkingsList().'
      )
    }

    const queryParameters: any = {}

    if (requestParameters["ordering"] != null) {
      queryParameters["ordering"] = requestParameters["ordering"]
    }

    if (requestParameters["page"] != null) {
      queryParameters["page"] = requestParameters["page"]
    }

    if (requestParameters["perPage"] != null) {
      queryParameters["per_page"] = requestParameters["perPage"]
    }

    if (requestParameters["search"] != null) {
      queryParameters["search"] = requestParameters["search"]
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request(
      {
        path: `/api/v1/bookmarks/{bookmark_pk}/bookmarkings/`.replace(
          `{${"bookmark_pk"}}`,
          encodeURIComponent(String(requestParameters["bookmarkPk"]))
        ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedBookmarkingListFromJSON(jsonValue))
  }

  /**
   */
  async apiV1BookmarksBookmarkingsList(
    requestParameters: ApiV1BookmarksBookmarkingsListRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<PaginatedBookmarkingList> {
    const response = await this.apiV1BookmarksBookmarkingsListRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   */
  async apiV1BookmarksBookmarkingsRetrieveRaw(
    requestParameters: ApiV1BookmarksBookmarkingsRetrieveRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<Bookmarking>> {
    if (requestParameters["bookmarkPk"] == null) {
      throw new runtime.RequiredError(
        "bookmarkPk",
        'Required parameter "bookmarkPk" was null or undefined when calling apiV1BookmarksBookmarkingsRetrieve().'
      )
    }

    if (requestParameters["id"] == null) {
      throw new runtime.RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling apiV1BookmarksBookmarkingsRetrieve().'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request(
      {
        path: `/api/v1/bookmarks/{bookmark_pk}/bookmarkings/{id}/`
          .replace(`{${"bookmark_pk"}}`, encodeURIComponent(String(requestParameters["bookmarkPk"])))
          .replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => BookmarkingFromJSON(jsonValue))
  }

  /**
   */
  async apiV1BookmarksBookmarkingsRetrieve(
    requestParameters: ApiV1BookmarksBookmarkingsRetrieveRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<Bookmarking> {
    const response = await this.apiV1BookmarksBookmarkingsRetrieveRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   */
  async apiV1BookmarksCreateRaw(
    requestParameters: ApiV1BookmarksCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<Bookmark>> {
    if (requestParameters["id"] == null) {
      throw new runtime.RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling apiV1BookmarksCreate().'
      )
    }

    if (requestParameters["title"] == null) {
      throw new runtime.RequiredError(
        "title",
        'Required parameter "title" was null or undefined when calling apiV1BookmarksCreate().'
      )
    }

    if (requestParameters["bookmarkingsCount"] == null) {
      throw new runtime.RequiredError(
        "bookmarkingsCount",
        'Required parameter "bookmarkingsCount" was null or undefined when calling apiV1BookmarksCreate().'
      )
    }

    if (requestParameters["createdAt"] == null) {
      throw new runtime.RequiredError(
        "createdAt",
        'Required parameter "createdAt" was null or undefined when calling apiV1BookmarksCreate().'
      )
    }

    if (requestParameters["updatedAt"] == null) {
      throw new runtime.RequiredError(
        "updatedAt",
        'Required parameter "updatedAt" was null or undefined when calling apiV1BookmarksCreate().'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const consumes: runtime.Consume[] = [
      { contentType: "application/x-www-form-urlencoded" },
      { contentType: "multipart/form-data" },
      { contentType: "application/json" }
    ]
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes)

    let formParams: { append(param: string, value: any): any }
    let useForm = false
    if (useForm) {
      formParams = new FormData()
    } else {
      formParams = new URLSearchParams()
    }

    if (requestParameters["id"] != null) {
      formParams.append("id", requestParameters["id"] as any)
    }

    if (requestParameters["title"] != null) {
      formParams.append("title", requestParameters["title"] as any)
    }

    if (requestParameters["bookmarkingsCount"] != null) {
      formParams.append("bookmarkings_count", requestParameters["bookmarkingsCount"] as any)
    }

    if (requestParameters["createdAt"] != null) {
      formParams.append("created_at", (requestParameters["createdAt"] as any).toISOString())
    }

    if (requestParameters["updatedAt"] != null) {
      formParams.append("updated_at", (requestParameters["updatedAt"] as any).toISOString())
    }

    const response = await this.request(
      {
        path: `/api/v1/bookmarks/`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: formParams
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => BookmarkFromJSON(jsonValue))
  }

  /**
   */
  async apiV1BookmarksCreate(
    requestParameters: ApiV1BookmarksCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<Bookmark> {
    const response = await this.apiV1BookmarksCreateRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   */
  async apiV1BookmarksDestroyRaw(
    requestParameters: ApiV1BookmarksDestroyRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters["id"] == null) {
      throw new runtime.RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling apiV1BookmarksDestroy().'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request(
      {
        path: `/api/v1/bookmarks/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters
      },
      initOverrides
    )

    return new runtime.VoidApiResponse(response)
  }

  /**
   */
  async apiV1BookmarksDestroy(
    requestParameters: ApiV1BookmarksDestroyRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.apiV1BookmarksDestroyRaw(requestParameters, initOverrides)
  }

  /**
   */
  async apiV1BookmarksListRaw(
    requestParameters: ApiV1BookmarksListRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<PaginatedBookmarkList>> {
    const queryParameters: any = {}

    if (requestParameters["ordering"] != null) {
      queryParameters["ordering"] = requestParameters["ordering"]
    }

    if (requestParameters["page"] != null) {
      queryParameters["page"] = requestParameters["page"]
    }

    if (requestParameters["perPage"] != null) {
      queryParameters["per_page"] = requestParameters["perPage"]
    }

    if (requestParameters["search"] != null) {
      queryParameters["search"] = requestParameters["search"]
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request(
      {
        path: `/api/v1/bookmarks/`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedBookmarkListFromJSON(jsonValue))
  }

  /**
   */
  async apiV1BookmarksList(
    requestParameters: ApiV1BookmarksListRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<PaginatedBookmarkList> {
    const response = await this.apiV1BookmarksListRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   */
  async apiV1BookmarksPartialUpdateRaw(
    requestParameters: ApiV1BookmarksPartialUpdateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<Bookmark>> {
    if (requestParameters["id"] == null) {
      throw new runtime.RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling apiV1BookmarksPartialUpdate().'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const consumes: runtime.Consume[] = [
      { contentType: "application/x-www-form-urlencoded" },
      { contentType: "multipart/form-data" },
      { contentType: "application/json" }
    ]
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes)

    let formParams: { append(param: string, value: any): any }
    let useForm = false
    if (useForm) {
      formParams = new FormData()
    } else {
      formParams = new URLSearchParams()
    }

    if (requestParameters["id2"] != null) {
      formParams.append("id", requestParameters["id2"] as any)
    }

    if (requestParameters["title"] != null) {
      formParams.append("title", requestParameters["title"] as any)
    }

    if (requestParameters["bookmarkingsCount"] != null) {
      formParams.append("bookmarkings_count", requestParameters["bookmarkingsCount"] as any)
    }

    if (requestParameters["createdAt"] != null) {
      formParams.append("created_at", (requestParameters["createdAt"] as any).toISOString())
    }

    if (requestParameters["updatedAt"] != null) {
      formParams.append("updated_at", (requestParameters["updatedAt"] as any).toISOString())
    }

    const response = await this.request(
      {
        path: `/api/v1/bookmarks/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
        method: "PATCH",
        headers: headerParameters,
        query: queryParameters,
        body: formParams
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => BookmarkFromJSON(jsonValue))
  }

  /**
   */
  async apiV1BookmarksPartialUpdate(
    requestParameters: ApiV1BookmarksPartialUpdateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<Bookmark> {
    const response = await this.apiV1BookmarksPartialUpdateRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   */
  async apiV1BookmarksRetrieveRaw(
    requestParameters: ApiV1BookmarksRetrieveRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<Bookmark>> {
    if (requestParameters["id"] == null) {
      throw new runtime.RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling apiV1BookmarksRetrieve().'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request(
      {
        path: `/api/v1/bookmarks/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => BookmarkFromJSON(jsonValue))
  }

  /**
   */
  async apiV1BookmarksRetrieve(
    requestParameters: ApiV1BookmarksRetrieveRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<Bookmark> {
    const response = await this.apiV1BookmarksRetrieveRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   */
  async apiV1BookmarksUpdateRaw(
    requestParameters: ApiV1BookmarksUpdateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<Bookmark>> {
    if (requestParameters["id"] == null) {
      throw new runtime.RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling apiV1BookmarksUpdate().'
      )
    }

    if (requestParameters["id2"] == null) {
      throw new runtime.RequiredError(
        "id2",
        'Required parameter "id2" was null or undefined when calling apiV1BookmarksUpdate().'
      )
    }

    if (requestParameters["title"] == null) {
      throw new runtime.RequiredError(
        "title",
        'Required parameter "title" was null or undefined when calling apiV1BookmarksUpdate().'
      )
    }

    if (requestParameters["bookmarkingsCount"] == null) {
      throw new runtime.RequiredError(
        "bookmarkingsCount",
        'Required parameter "bookmarkingsCount" was null or undefined when calling apiV1BookmarksUpdate().'
      )
    }

    if (requestParameters["createdAt"] == null) {
      throw new runtime.RequiredError(
        "createdAt",
        'Required parameter "createdAt" was null or undefined when calling apiV1BookmarksUpdate().'
      )
    }

    if (requestParameters["updatedAt"] == null) {
      throw new runtime.RequiredError(
        "updatedAt",
        'Required parameter "updatedAt" was null or undefined when calling apiV1BookmarksUpdate().'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const consumes: runtime.Consume[] = [
      { contentType: "application/x-www-form-urlencoded" },
      { contentType: "multipart/form-data" },
      { contentType: "application/json" }
    ]
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes)

    let formParams: { append(param: string, value: any): any }
    let useForm = false
    if (useForm) {
      formParams = new FormData()
    } else {
      formParams = new URLSearchParams()
    }

    if (requestParameters["id2"] != null) {
      formParams.append("id", requestParameters["id2"] as any)
    }

    if (requestParameters["title"] != null) {
      formParams.append("title", requestParameters["title"] as any)
    }

    if (requestParameters["bookmarkingsCount"] != null) {
      formParams.append("bookmarkings_count", requestParameters["bookmarkingsCount"] as any)
    }

    if (requestParameters["createdAt"] != null) {
      formParams.append("created_at", (requestParameters["createdAt"] as any).toISOString())
    }

    if (requestParameters["updatedAt"] != null) {
      formParams.append("updated_at", (requestParameters["updatedAt"] as any).toISOString())
    }

    const response = await this.request(
      {
        path: `/api/v1/bookmarks/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
        method: "PUT",
        headers: headerParameters,
        query: queryParameters,
        body: formParams
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => BookmarkFromJSON(jsonValue))
  }

  /**
   */
  async apiV1BookmarksUpdate(
    requestParameters: ApiV1BookmarksUpdateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<Bookmark> {
    const response = await this.apiV1BookmarksUpdateRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Retrieve a list of bookmark IDs for a specific meme.
   */
  async apiV1MemesBookmarkIdsRetrieveRaw(
    requestParameters: ApiV1MemesBookmarkIdsRetrieveRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<ApiV1MemesBookmarkIdsRetrieve200Response>> {
    if (requestParameters["memeId"] == null) {
      throw new runtime.RequiredError(
        "memeId",
        'Required parameter "memeId" was null or undefined when calling apiV1MemesBookmarkIdsRetrieve().'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request(
      {
        path: `/api/v1/memes/{meme_id}/bookmark_ids`.replace(
          `{${"meme_id"}}`,
          encodeURIComponent(String(requestParameters["memeId"]))
        ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ApiV1MemesBookmarkIdsRetrieve200ResponseFromJSON(jsonValue)
    )
  }

  /**
   * Retrieve a list of bookmark IDs for a specific meme.
   */
  async apiV1MemesBookmarkIdsRetrieve(
    requestParameters: ApiV1MemesBookmarkIdsRetrieveRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<ApiV1MemesBookmarkIdsRetrieve200Response> {
    const response = await this.apiV1MemesBookmarkIdsRetrieveRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   */
  async apiV1MemesListRaw(
    requestParameters: ApiV1MemesListRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<PaginatedMemeList>> {
    const queryParameters: any = {}

    if (requestParameters["ordering"] != null) {
      queryParameters["ordering"] = requestParameters["ordering"]
    }

    if (requestParameters["page"] != null) {
      queryParameters["page"] = requestParameters["page"]
    }

    if (requestParameters["perPage"] != null) {
      queryParameters["per_page"] = requestParameters["perPage"]
    }

    if (requestParameters["search"] != null) {
      queryParameters["search"] = requestParameters["search"]
    }

    if (requestParameters["tagsCategoryName"] != null) {
      queryParameters["tags__category__name"] = requestParameters["tagsCategoryName"]
    }

    if (requestParameters["type"] != null) {
      queryParameters["type"] = requestParameters["type"]
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request(
      {
        path: `/api/v1/memes/`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedMemeListFromJSON(jsonValue))
  }

  /**
   */
  async apiV1MemesList(
    requestParameters: ApiV1MemesListRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<PaginatedMemeList> {
    const response = await this.apiV1MemesListRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Retrieve a list of memes related to the given meme ID.
   */
  async apiV1MemesRelatedListRaw(
    requestParameters: ApiV1MemesRelatedListRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<Array<Meme>>> {
    if (requestParameters["memeId"] == null) {
      throw new runtime.RequiredError(
        "memeId",
        'Required parameter "memeId" was null or undefined when calling apiV1MemesRelatedList().'
      )
    }

    const queryParameters: any = {}

    if (requestParameters["count"] != null) {
      queryParameters["count"] = requestParameters["count"]
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request(
      {
        path: `/api/v1/memes/{meme_id}/related`.replace(
          `{${"meme_id"}}`,
          encodeURIComponent(String(requestParameters["memeId"]))
        ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MemeFromJSON))
  }

  /**
   * Retrieve a list of memes related to the given meme ID.
   */
  async apiV1MemesRelatedList(
    requestParameters: ApiV1MemesRelatedListRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<Array<Meme>> {
    const response = await this.apiV1MemesRelatedListRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   */
  async apiV1MemesRetrieveRaw(
    requestParameters: ApiV1MemesRetrieveRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<Meme>> {
    if (requestParameters["id"] == null) {
      throw new runtime.RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling apiV1MemesRetrieve().'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request(
      {
        path: `/api/v1/memes/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => MemeFromJSON(jsonValue))
  }

  /**
   */
  async apiV1MemesRetrieve(
    requestParameters: ApiV1MemesRetrieveRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<Meme> {
    const response = await this.apiV1MemesRetrieveRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Retrieve tags grouped by their first letter, with a specified limit per letter.
   */
  async apiV1TagsByFirstLetterListRaw(
    requestParameters: ApiV1TagsByFirstLetterListRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<Array<Tag>>> {
    const queryParameters: any = {}

    if (requestParameters["count"] != null) {
      queryParameters["count"] = requestParameters["count"]
    }

    if (requestParameters["orderBy"] != null) {
      queryParameters["order_by"] = requestParameters["orderBy"]
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request(
      {
        path: `/api/v1/tags/by-first-letter/`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TagFromJSON))
  }

  /**
   * Retrieve tags grouped by their first letter, with a specified limit per letter.
   */
  async apiV1TagsByFirstLetterList(
    requestParameters: ApiV1TagsByFirstLetterListRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<Array<Tag>> {
    const response = await this.apiV1TagsByFirstLetterListRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   */
  async apiV1TagsFavoriteListRaw(
    requestParameters: ApiV1TagsFavoriteListRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<PaginatedTagList>> {
    const queryParameters: any = {}

    if (requestParameters["ordering"] != null) {
      queryParameters["ordering"] = requestParameters["ordering"]
    }

    if (requestParameters["page"] != null) {
      queryParameters["page"] = requestParameters["page"]
    }

    if (requestParameters["perPage"] != null) {
      queryParameters["per_page"] = requestParameters["perPage"]
    }

    if (requestParameters["search"] != null) {
      queryParameters["search"] = requestParameters["search"]
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request(
      {
        path: `/api/v1/tags/favorite/`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedTagListFromJSON(jsonValue))
  }

  /**
   */
  async apiV1TagsFavoriteList(
    requestParameters: ApiV1TagsFavoriteListRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<PaginatedTagList> {
    const response = await this.apiV1TagsFavoriteListRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Retrieve a list of distinct first letters from available tags.
   */
  async apiV1TagsFirstLettersRetrieveRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<Array<string>>> {
    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request(
      {
        path: `/api/v1/tags/first-letters/`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      },
      initOverrides
    )

    return new runtime.JSONApiResponse<any>(response)
  }

  /**
   * Retrieve a list of distinct first letters from available tags.
   */
  async apiV1TagsFirstLettersRetrieve(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<Array<string>> {
    const response = await this.apiV1TagsFirstLettersRetrieveRaw(initOverrides)
    return await response.value()
  }

  /**
   */
  async apiV1TagsListRaw(
    requestParameters: ApiV1TagsListRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<PaginatedTagList>> {
    const queryParameters: any = {}

    if (requestParameters["category"] != null) {
      queryParameters["category"] = requestParameters["category"]
    }

    if (requestParameters["firstLetter"] != null) {
      queryParameters["first_letter"] = requestParameters["firstLetter"]
    }

    if (requestParameters["ordering"] != null) {
      queryParameters["ordering"] = requestParameters["ordering"]
    }

    if (requestParameters["page"] != null) {
      queryParameters["page"] = requestParameters["page"]
    }

    if (requestParameters["perPage"] != null) {
      queryParameters["per_page"] = requestParameters["perPage"]
    }

    if (requestParameters["search"] != null) {
      queryParameters["search"] = requestParameters["search"]
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request(
      {
        path: `/api/v1/tags/`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedTagListFromJSON(jsonValue))
  }

  /**
   */
  async apiV1TagsList(
    requestParameters: ApiV1TagsListRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<PaginatedTagList> {
    const response = await this.apiV1TagsListRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Removes the specified Bookmarking if it belongs to the current user. Returns 204 on success.
   * Delete a Bookmarking
   */
  async bookmarkingDeleteRaw(
    requestParameters: BookmarkingDeleteRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters["bookmarkingId"] == null) {
      throw new runtime.RequiredError(
        "bookmarkingId",
        'Required parameter "bookmarkingId" was null or undefined when calling bookmarkingDelete().'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request(
      {
        path: `/api/v1/bookmarkings/{bookmarking_id}`.replace(
          `{${"bookmarking_id"}}`,
          encodeURIComponent(String(requestParameters["bookmarkingId"]))
        ),
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters
      },
      initOverrides
    )

    return new runtime.VoidApiResponse(response)
  }

  /**
   * Removes the specified Bookmarking if it belongs to the current user. Returns 204 on success.
   * Delete a Bookmarking
   */
  async bookmarkingDelete(
    requestParameters: BookmarkingDeleteRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.bookmarkingDeleteRaw(requestParameters, initOverrides)
  }

  /**
   * 단일 밈과 여러 북마크에 대해서 동시에 다룹니다.
   * bulk sync bookmarkings
   */
  async bookmarkingSyncRaw(
    requestParameters: BookmarkingSyncOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<any>> {
    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters["Content-Type"] = "application/json"

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request(
      {
        path: `/api/v1/bookmarkings/`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: BookmarkingSyncRequestToJSON(requestParameters["bookmarkingSyncRequest"])
      },
      initOverrides
    )

    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new runtime.JSONApiResponse<any>(response)
    } else {
      return new runtime.TextApiResponse(response) as any
    }
  }

  /**
   * 단일 밈과 여러 북마크에 대해서 동시에 다룹니다.
   * bulk sync bookmarkings
   */
  async bookmarkingSync(
    requestParameters: BookmarkingSyncOperationRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<any> {
    const response = await this.bookmarkingSyncRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * 사용자 계정 및 연결된 소셜 계정을 삭제합니다.
   */
  async deleteUserAccountRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request(
      {
        path: `/api/v1/accounts/user/delete/`,
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters
      },
      initOverrides
    )

    return new runtime.VoidApiResponse(response)
  }

  /**
   * 사용자 계정 및 연결된 소셜 계정을 삭제합니다.
   */
  async deleteUserAccount(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
    await this.deleteUserAccountRaw(initOverrides)
  }
}

/**
 * @export
 */
export const ApiV1MemesListTypeEnum = {
  Audio: "Audio",
  Image: "Image",
  Text: "Text",
  Video: "Video"
} as const
export type ApiV1MemesListTypeEnum = (typeof ApiV1MemesListTypeEnum)[keyof typeof ApiV1MemesListTypeEnum]
/**
 * @export
 */
export const ApiV1TagsByFirstLetterListOrderByEnum = {
  CreatedAt: "created_at",
  Name: "name",
  UpdatedAt: "updated_at"
} as const
export type ApiV1TagsByFirstLetterListOrderByEnum =
  (typeof ApiV1TagsByFirstLetterListOrderByEnum)[keyof typeof ApiV1TagsByFirstLetterListOrderByEnum]
