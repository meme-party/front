/* tslint:disable */
/* eslint-disable */
/**
 * Dionysus API
 * Meme Project
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: dev.shinkeonkim@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from "../runtime"
import type {
  JWT,
  KakaoAuthResponse,
  RestAuthDetail,
  SocialAccount,
  SocialLogin,
  TokenRefresh,
  TokenVerify,
  UserDetail
} from "../models/index"
import {
  JWTFromJSON,
  JWTToJSON,
  KakaoAuthResponseFromJSON,
  KakaoAuthResponseToJSON,
  RestAuthDetailFromJSON,
  RestAuthDetailToJSON,
  SocialAccountFromJSON,
  SocialAccountToJSON,
  SocialLoginFromJSON,
  SocialLoginToJSON,
  TokenRefreshFromJSON,
  TokenRefreshToJSON,
  TokenVerifyFromJSON,
  TokenVerifyToJSON,
  UserDetailFromJSON,
  UserDetailToJSON
} from "../models/index"

export interface ApiV1AccountsKakaoLoginCallbackRetrieveRequest {
  code: string
  redirectUri?: string
}

export interface ApiV1AccountsKakaoLoginFinishCreateRequest {
  accessToken?: string
  code?: string
  idToken?: string
}

export interface ApiV1AccountsLoginCreateRequest {
  password: string
  username?: string
  email?: string
}

export interface ApiV1AccountsPasswordChangeCreateRequest {
  newPassword1: string
  newPassword2: string
}

export interface ApiV1AccountsPasswordResetConfirmCreateRequest {
  newPassword1: string
  newPassword2: string
  uid: string
  token: string
}

export interface ApiV1AccountsPasswordResetCreateRequest {
  email: string
}

export interface ApiV1AccountsTokenRefreshCreateRequest {
  access: string
  refresh: string
}

export interface ApiV1AccountsTokenVerifyCreateRequest {
  token: string
}

export interface ApiV1AccountsUserPartialUpdateRequest {
  pk?: number
  email?: string
  username?: string
  socialAccount?: Array<SocialAccount>
}

export interface ApiV1AccountsUserUpdateRequest {
  pk: number
  email: string
  socialAccount: Array<SocialAccount>
  username?: string
}

/**
 *
 */
export class ApiApi extends runtime.BaseAPI {
  /**
   * 카카오 인증 후 받은 인가 코드(code)를 이용해 액세스 토큰을 요청하고, 회원가입 또는 로그인 처리를 합니다.
   * Kakao OAuth Callback
   */
  async apiV1AccountsKakaoLoginCallbackRetrieveRaw(
    requestParameters: ApiV1AccountsKakaoLoginCallbackRetrieveRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<KakaoAuthResponse>> {
    if (requestParameters["code"] == null) {
      throw new runtime.RequiredError(
        "code",
        'Required parameter "code" was null or undefined when calling apiV1AccountsKakaoLoginCallbackRetrieve().'
      )
    }

    const queryParameters: any = {}

    if (requestParameters["code"] != null) {
      queryParameters["code"] = requestParameters["code"]
    }

    if (requestParameters["redirectUri"] != null) {
      queryParameters["redirect_uri"] = requestParameters["redirectUri"]
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request(
      {
        path: `/api/v1/accounts/kakao/login/callback/`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => KakaoAuthResponseFromJSON(jsonValue))
  }

  /**
   * 카카오 인증 후 받은 인가 코드(code)를 이용해 액세스 토큰을 요청하고, 회원가입 또는 로그인 처리를 합니다.
   * Kakao OAuth Callback
   */
  async apiV1AccountsKakaoLoginCallbackRetrieve(
    requestParameters: ApiV1AccountsKakaoLoginCallbackRetrieveRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<KakaoAuthResponse> {
    const response = await this.apiV1AccountsKakaoLoginCallbackRetrieveRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * class used for social authentications example usage for facebook with access_token ------------- from allauth.socialaccount.providers.facebook.views import FacebookOAuth2Adapter  class FacebookLogin(SocialLoginView):     adapter_class = FacebookOAuth2Adapter -------------  example usage for facebook with code  ------------- from allauth.socialaccount.providers.facebook.views import FacebookOAuth2Adapter from allauth.socialaccount.providers.oauth2.client import OAuth2Client  class FacebookLogin(SocialLoginView):     adapter_class = FacebookOAuth2Adapter     client_class = OAuth2Client     callback_url = \'localhost:8000\' -------------
   */
  async apiV1AccountsKakaoLoginFinishCreateRaw(
    requestParameters: ApiV1AccountsKakaoLoginFinishCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<SocialLogin>> {
    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const consumes: runtime.Consume[] = [
      { contentType: "application/x-www-form-urlencoded" },
      { contentType: "multipart/form-data" },
      { contentType: "application/json" }
    ]
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes)

    let formParams: { append(param: string, value: any): any }
    let useForm = false
    if (useForm) {
      formParams = new FormData()
    } else {
      formParams = new URLSearchParams()
    }

    if (requestParameters["accessToken"] != null) {
      formParams.append("access_token", requestParameters["accessToken"] as any)
    }

    if (requestParameters["code"] != null) {
      formParams.append("code", requestParameters["code"] as any)
    }

    if (requestParameters["idToken"] != null) {
      formParams.append("id_token", requestParameters["idToken"] as any)
    }

    const response = await this.request(
      {
        path: `/api/v1/accounts/kakao/login/finish/`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: formParams
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => SocialLoginFromJSON(jsonValue))
  }

  /**
   * class used for social authentications example usage for facebook with access_token ------------- from allauth.socialaccount.providers.facebook.views import FacebookOAuth2Adapter  class FacebookLogin(SocialLoginView):     adapter_class = FacebookOAuth2Adapter -------------  example usage for facebook with code  ------------- from allauth.socialaccount.providers.facebook.views import FacebookOAuth2Adapter from allauth.socialaccount.providers.oauth2.client import OAuth2Client  class FacebookLogin(SocialLoginView):     adapter_class = FacebookOAuth2Adapter     client_class = OAuth2Client     callback_url = \'localhost:8000\' -------------
   */
  async apiV1AccountsKakaoLoginFinishCreate(
    requestParameters: ApiV1AccountsKakaoLoginFinishCreateRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<SocialLogin> {
    const response = await this.apiV1AccountsKakaoLoginFinishCreateRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Check the credentials and return the REST Token if the credentials are valid and authenticated. Calls Django Auth login method to register User ID in Django session framework  Accept the following POST parameters: username, password Return the REST Framework Token Object\'s key.
   */
  async apiV1AccountsLoginCreateRaw(
    requestParameters: ApiV1AccountsLoginCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<JWT>> {
    if (requestParameters["password"] == null) {
      throw new runtime.RequiredError(
        "password",
        'Required parameter "password" was null or undefined when calling apiV1AccountsLoginCreate().'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const consumes: runtime.Consume[] = [
      { contentType: "application/x-www-form-urlencoded" },
      { contentType: "multipart/form-data" },
      { contentType: "application/json" }
    ]
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes)

    let formParams: { append(param: string, value: any): any }
    let useForm = false
    if (useForm) {
      formParams = new FormData()
    } else {
      formParams = new URLSearchParams()
    }

    if (requestParameters["username"] != null) {
      formParams.append("username", requestParameters["username"] as any)
    }

    if (requestParameters["email"] != null) {
      formParams.append("email", requestParameters["email"] as any)
    }

    if (requestParameters["password"] != null) {
      formParams.append("password", requestParameters["password"] as any)
    }

    const response = await this.request(
      {
        path: `/api/v1/accounts/login/`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: formParams
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => JWTFromJSON(jsonValue))
  }

  /**
   * Check the credentials and return the REST Token if the credentials are valid and authenticated. Calls Django Auth login method to register User ID in Django session framework  Accept the following POST parameters: username, password Return the REST Framework Token Object\'s key.
   */
  async apiV1AccountsLoginCreate(
    requestParameters: ApiV1AccountsLoginCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<JWT> {
    const response = await this.apiV1AccountsLoginCreateRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Calls Django logout method and delete the Token object assigned to the current User object.  Accepts/Returns nothing.
   */
  async apiV1AccountsLogoutCreateRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<RestAuthDetail>> {
    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request(
      {
        path: `/api/v1/accounts/logout/`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => RestAuthDetailFromJSON(jsonValue))
  }

  /**
   * Calls Django logout method and delete the Token object assigned to the current User object.  Accepts/Returns nothing.
   */
  async apiV1AccountsLogoutCreate(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestAuthDetail> {
    const response = await this.apiV1AccountsLogoutCreateRaw(initOverrides)
    return await response.value()
  }

  /**
   * Calls Django Auth SetPasswordForm save method.  Accepts the following POST parameters: new_password1, new_password2 Returns the success/fail message.
   */
  async apiV1AccountsPasswordChangeCreateRaw(
    requestParameters: ApiV1AccountsPasswordChangeCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<RestAuthDetail>> {
    if (requestParameters["newPassword1"] == null) {
      throw new runtime.RequiredError(
        "newPassword1",
        'Required parameter "newPassword1" was null or undefined when calling apiV1AccountsPasswordChangeCreate().'
      )
    }

    if (requestParameters["newPassword2"] == null) {
      throw new runtime.RequiredError(
        "newPassword2",
        'Required parameter "newPassword2" was null or undefined when calling apiV1AccountsPasswordChangeCreate().'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const consumes: runtime.Consume[] = [
      { contentType: "application/x-www-form-urlencoded" },
      { contentType: "multipart/form-data" },
      { contentType: "application/json" }
    ]
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes)

    let formParams: { append(param: string, value: any): any }
    let useForm = false
    if (useForm) {
      formParams = new FormData()
    } else {
      formParams = new URLSearchParams()
    }

    if (requestParameters["newPassword1"] != null) {
      formParams.append("new_password1", requestParameters["newPassword1"] as any)
    }

    if (requestParameters["newPassword2"] != null) {
      formParams.append("new_password2", requestParameters["newPassword2"] as any)
    }

    const response = await this.request(
      {
        path: `/api/v1/accounts/password/change/`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: formParams
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => RestAuthDetailFromJSON(jsonValue))
  }

  /**
   * Calls Django Auth SetPasswordForm save method.  Accepts the following POST parameters: new_password1, new_password2 Returns the success/fail message.
   */
  async apiV1AccountsPasswordChangeCreate(
    requestParameters: ApiV1AccountsPasswordChangeCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<RestAuthDetail> {
    const response = await this.apiV1AccountsPasswordChangeCreateRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Password reset e-mail link is confirmed, therefore this resets the user\'s password.  Accepts the following POST parameters: token, uid,     new_password1, new_password2 Returns the success/fail message.
   */
  async apiV1AccountsPasswordResetConfirmCreateRaw(
    requestParameters: ApiV1AccountsPasswordResetConfirmCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<RestAuthDetail>> {
    if (requestParameters["newPassword1"] == null) {
      throw new runtime.RequiredError(
        "newPassword1",
        'Required parameter "newPassword1" was null or undefined when calling apiV1AccountsPasswordResetConfirmCreate().'
      )
    }

    if (requestParameters["newPassword2"] == null) {
      throw new runtime.RequiredError(
        "newPassword2",
        'Required parameter "newPassword2" was null or undefined when calling apiV1AccountsPasswordResetConfirmCreate().'
      )
    }

    if (requestParameters["uid"] == null) {
      throw new runtime.RequiredError(
        "uid",
        'Required parameter "uid" was null or undefined when calling apiV1AccountsPasswordResetConfirmCreate().'
      )
    }

    if (requestParameters["token"] == null) {
      throw new runtime.RequiredError(
        "token",
        'Required parameter "token" was null or undefined when calling apiV1AccountsPasswordResetConfirmCreate().'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const consumes: runtime.Consume[] = [
      { contentType: "application/x-www-form-urlencoded" },
      { contentType: "multipart/form-data" },
      { contentType: "application/json" }
    ]
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes)

    let formParams: { append(param: string, value: any): any }
    let useForm = false
    if (useForm) {
      formParams = new FormData()
    } else {
      formParams = new URLSearchParams()
    }

    if (requestParameters["newPassword1"] != null) {
      formParams.append("new_password1", requestParameters["newPassword1"] as any)
    }

    if (requestParameters["newPassword2"] != null) {
      formParams.append("new_password2", requestParameters["newPassword2"] as any)
    }

    if (requestParameters["uid"] != null) {
      formParams.append("uid", requestParameters["uid"] as any)
    }

    if (requestParameters["token"] != null) {
      formParams.append("token", requestParameters["token"] as any)
    }

    const response = await this.request(
      {
        path: `/api/v1/accounts/password/reset/confirm/`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: formParams
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => RestAuthDetailFromJSON(jsonValue))
  }

  /**
   * Password reset e-mail link is confirmed, therefore this resets the user\'s password.  Accepts the following POST parameters: token, uid,     new_password1, new_password2 Returns the success/fail message.
   */
  async apiV1AccountsPasswordResetConfirmCreate(
    requestParameters: ApiV1AccountsPasswordResetConfirmCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<RestAuthDetail> {
    const response = await this.apiV1AccountsPasswordResetConfirmCreateRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Calls Django Auth PasswordResetForm save method.  Accepts the following POST parameters: email Returns the success/fail message.
   */
  async apiV1AccountsPasswordResetCreateRaw(
    requestParameters: ApiV1AccountsPasswordResetCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<RestAuthDetail>> {
    if (requestParameters["email"] == null) {
      throw new runtime.RequiredError(
        "email",
        'Required parameter "email" was null or undefined when calling apiV1AccountsPasswordResetCreate().'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const consumes: runtime.Consume[] = [
      { contentType: "application/x-www-form-urlencoded" },
      { contentType: "multipart/form-data" },
      { contentType: "application/json" }
    ]
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes)

    let formParams: { append(param: string, value: any): any }
    let useForm = false
    if (useForm) {
      formParams = new FormData()
    } else {
      formParams = new URLSearchParams()
    }

    if (requestParameters["email"] != null) {
      formParams.append("email", requestParameters["email"] as any)
    }

    const response = await this.request(
      {
        path: `/api/v1/accounts/password/reset/`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: formParams
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => RestAuthDetailFromJSON(jsonValue))
  }

  /**
   * Calls Django Auth PasswordResetForm save method.  Accepts the following POST parameters: email Returns the success/fail message.
   */
  async apiV1AccountsPasswordResetCreate(
    requestParameters: ApiV1AccountsPasswordResetCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<RestAuthDetail> {
    const response = await this.apiV1AccountsPasswordResetCreateRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
   */
  async apiV1AccountsTokenRefreshCreateRaw(
    requestParameters: ApiV1AccountsTokenRefreshCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<TokenRefresh>> {
    if (requestParameters["access"] == null) {
      throw new runtime.RequiredError(
        "access",
        'Required parameter "access" was null or undefined when calling apiV1AccountsTokenRefreshCreate().'
      )
    }

    if (requestParameters["refresh"] == null) {
      throw new runtime.RequiredError(
        "refresh",
        'Required parameter "refresh" was null or undefined when calling apiV1AccountsTokenRefreshCreate().'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    const consumes: runtime.Consume[] = [
      { contentType: "application/x-www-form-urlencoded" },
      { contentType: "multipart/form-data" },
      { contentType: "application/json" }
    ]
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes)

    let formParams: { append(param: string, value: any): any }
    let useForm = false
    if (useForm) {
      formParams = new FormData()
    } else {
      formParams = new URLSearchParams()
    }

    if (requestParameters["access"] != null) {
      formParams.append("access", requestParameters["access"] as any)
    }

    if (requestParameters["refresh"] != null) {
      formParams.append("refresh", requestParameters["refresh"] as any)
    }

    const response = await this.request(
      {
        path: `/api/v1/accounts/token/refresh/`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: formParams
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => TokenRefreshFromJSON(jsonValue))
  }

  /**
   * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
   */
  async apiV1AccountsTokenRefreshCreate(
    requestParameters: ApiV1AccountsTokenRefreshCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<TokenRefresh> {
    const response = await this.apiV1AccountsTokenRefreshCreateRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
   */
  async apiV1AccountsTokenVerifyCreateRaw(
    requestParameters: ApiV1AccountsTokenVerifyCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<TokenVerify>> {
    if (requestParameters["token"] == null) {
      throw new runtime.RequiredError(
        "token",
        'Required parameter "token" was null or undefined when calling apiV1AccountsTokenVerifyCreate().'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    const consumes: runtime.Consume[] = [
      { contentType: "application/x-www-form-urlencoded" },
      { contentType: "multipart/form-data" },
      { contentType: "application/json" }
    ]
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes)

    let formParams: { append(param: string, value: any): any }
    let useForm = false
    if (useForm) {
      formParams = new FormData()
    } else {
      formParams = new URLSearchParams()
    }

    if (requestParameters["token"] != null) {
      formParams.append("token", requestParameters["token"] as any)
    }

    const response = await this.request(
      {
        path: `/api/v1/accounts/token/verify/`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: formParams
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => TokenVerifyFromJSON(jsonValue))
  }

  /**
   * Takes a token and indicates if it is valid.  This view provides no information about a token\'s fitness for a particular use.
   */
  async apiV1AccountsTokenVerifyCreate(
    requestParameters: ApiV1AccountsTokenVerifyCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<TokenVerify> {
    const response = await this.apiV1AccountsTokenVerifyCreateRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
   */
  async apiV1AccountsUserPartialUpdateRaw(
    requestParameters: ApiV1AccountsUserPartialUpdateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<UserDetail>> {
    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const consumes: runtime.Consume[] = [
      { contentType: "application/x-www-form-urlencoded" },
      { contentType: "multipart/form-data" },
      { contentType: "application/json" }
    ]
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes)

    let formParams: { append(param: string, value: any): any }
    let useForm = false
    if (useForm) {
      formParams = new FormData()
    } else {
      formParams = new URLSearchParams()
    }

    if (requestParameters["pk"] != null) {
      formParams.append("pk", requestParameters["pk"] as any)
    }

    if (requestParameters["email"] != null) {
      formParams.append("email", requestParameters["email"] as any)
    }

    if (requestParameters["username"] != null) {
      formParams.append("username", requestParameters["username"] as any)
    }

    if (requestParameters["socialAccount"] != null) {
      formParams.append("social_account", requestParameters["socialAccount"]!.join(runtime.COLLECTION_FORMATS["csv"]))
    }

    const response = await this.request(
      {
        path: `/api/v1/accounts/user/`,
        method: "PATCH",
        headers: headerParameters,
        query: queryParameters,
        body: formParams
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => UserDetailFromJSON(jsonValue))
  }

  /**
   * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
   */
  async apiV1AccountsUserPartialUpdate(
    requestParameters: ApiV1AccountsUserPartialUpdateRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<UserDetail> {
    const response = await this.apiV1AccountsUserPartialUpdateRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
   */
  async apiV1AccountsUserRetrieveRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<UserDetail>> {
    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request(
      {
        path: `/api/v1/accounts/user/`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => UserDetailFromJSON(jsonValue))
  }

  /**
   * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
   */
  async apiV1AccountsUserRetrieve(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserDetail> {
    const response = await this.apiV1AccountsUserRetrieveRaw(initOverrides)
    return await response.value()
  }

  /**
   * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
   */
  async apiV1AccountsUserUpdateRaw(
    requestParameters: ApiV1AccountsUserUpdateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<UserDetail>> {
    if (requestParameters["pk"] == null) {
      throw new runtime.RequiredError(
        "pk",
        'Required parameter "pk" was null or undefined when calling apiV1AccountsUserUpdate().'
      )
    }

    if (requestParameters["email"] == null) {
      throw new runtime.RequiredError(
        "email",
        'Required parameter "email" was null or undefined when calling apiV1AccountsUserUpdate().'
      )
    }

    if (requestParameters["socialAccount"] == null) {
      throw new runtime.RequiredError(
        "socialAccount",
        'Required parameter "socialAccount" was null or undefined when calling apiV1AccountsUserUpdate().'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const consumes: runtime.Consume[] = [
      { contentType: "application/x-www-form-urlencoded" },
      { contentType: "multipart/form-data" },
      { contentType: "application/json" }
    ]
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes)

    let formParams: { append(param: string, value: any): any }
    let useForm = false
    if (useForm) {
      formParams = new FormData()
    } else {
      formParams = new URLSearchParams()
    }

    if (requestParameters["pk"] != null) {
      formParams.append("pk", requestParameters["pk"] as any)
    }

    if (requestParameters["email"] != null) {
      formParams.append("email", requestParameters["email"] as any)
    }

    if (requestParameters["username"] != null) {
      formParams.append("username", requestParameters["username"] as any)
    }

    if (requestParameters["socialAccount"] != null) {
      formParams.append("social_account", requestParameters["socialAccount"]!.join(runtime.COLLECTION_FORMATS["csv"]))
    }

    const response = await this.request(
      {
        path: `/api/v1/accounts/user/`,
        method: "PUT",
        headers: headerParameters,
        query: queryParameters,
        body: formParams
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => UserDetailFromJSON(jsonValue))
  }

  /**
   * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
   */
  async apiV1AccountsUserUpdate(
    requestParameters: ApiV1AccountsUserUpdateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<UserDetail> {
    const response = await this.apiV1AccountsUserUpdateRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * 사용자 계정 및 연결된 소셜 계정을 삭제합니다.
   */
  async deleteUserAccountRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request(
      {
        path: `/api/v1/accounts/user/delete/`,
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters
      },
      initOverrides
    )

    return new runtime.VoidApiResponse(response)
  }

  /**
   * 사용자 계정 및 연결된 소셜 계정을 삭제합니다.
   */
  async deleteUserAccount(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
    await this.deleteUserAccountRaw(initOverrides)
  }
}
