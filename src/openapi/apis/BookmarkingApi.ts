/* tslint:disable */
/* eslint-disable */
/**
 * Dionysus API
 * Meme Project
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: dev.shinkeonkim@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from "../runtime"
import type {
  ApiV1BookmarkingsWithoutBookmarkCreateRequest,
  Bookmarking,
  BookmarkingSyncRequest,
  PaginatedBookmarkingList
} from "../models/index"
import {
  ApiV1BookmarkingsWithoutBookmarkCreateRequestFromJSON,
  ApiV1BookmarkingsWithoutBookmarkCreateRequestToJSON,
  BookmarkingFromJSON,
  BookmarkingToJSON,
  BookmarkingSyncRequestFromJSON,
  BookmarkingSyncRequestToJSON,
  PaginatedBookmarkingListFromJSON,
  PaginatedBookmarkingListToJSON
} from "../models/index"

export interface ApiV1BookmarkingsWithoutBookmarkCreateOperationRequest {
  ordering?: string
  page?: number
  perPage?: number
  search?: string
  apiV1BookmarkingsWithoutBookmarkCreateRequest?: ApiV1BookmarkingsWithoutBookmarkCreateRequest
}

export interface ApiV1BookmarkingsWithoutBookmarkListRequest {
  ordering?: string
  page?: number
  perPage?: number
  search?: string
}

export interface ApiV1BookmarksBookmarkingsListRequest {
  bookmarkPk: number
  ordering?: string
  page?: number
  perPage?: number
  search?: string
}

export interface ApiV1BookmarksBookmarkingsRetrieveRequest {
  bookmarkPk: number
  id: number
}

export interface BookmarkingDeleteRequest {
  bookmarkingId: number
}

export interface BookmarkingSyncOperationRequest {
  bookmarkingSyncRequest?: BookmarkingSyncRequest
}

/**
 *
 */
export class BookmarkingApi extends runtime.BaseAPI {
  /**
   * 북마크가 없는 북마킹들에 대해 북마크를 일괄로 추가합니다.
   */
  async apiV1BookmarkingsWithoutBookmarkCreateRaw(
    requestParameters: ApiV1BookmarkingsWithoutBookmarkCreateOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<PaginatedBookmarkingList>> {
    const queryParameters: any = {}

    if (requestParameters["ordering"] != null) {
      queryParameters["ordering"] = requestParameters["ordering"]
    }

    if (requestParameters["page"] != null) {
      queryParameters["page"] = requestParameters["page"]
    }

    if (requestParameters["perPage"] != null) {
      queryParameters["per_page"] = requestParameters["perPage"]
    }

    if (requestParameters["search"] != null) {
      queryParameters["search"] = requestParameters["search"]
    }

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters["Content-Type"] = "application/json"

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request(
      {
        path: `/api/v1/bookmarkings-without-bookmark/`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: ApiV1BookmarkingsWithoutBookmarkCreateRequestToJSON(
          requestParameters["apiV1BookmarkingsWithoutBookmarkCreateRequest"]
        )
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedBookmarkingListFromJSON(jsonValue))
  }

  /**
   * 북마크가 없는 북마킹들에 대해 북마크를 일괄로 추가합니다.
   */
  async apiV1BookmarkingsWithoutBookmarkCreate(
    requestParameters: ApiV1BookmarkingsWithoutBookmarkCreateOperationRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<PaginatedBookmarkingList> {
    const response = await this.apiV1BookmarkingsWithoutBookmarkCreateRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * 북마크가 없는 북마킹들을 조회합니다.
   */
  async apiV1BookmarkingsWithoutBookmarkListRaw(
    requestParameters: ApiV1BookmarkingsWithoutBookmarkListRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<PaginatedBookmarkingList>> {
    const queryParameters: any = {}

    if (requestParameters["ordering"] != null) {
      queryParameters["ordering"] = requestParameters["ordering"]
    }

    if (requestParameters["page"] != null) {
      queryParameters["page"] = requestParameters["page"]
    }

    if (requestParameters["perPage"] != null) {
      queryParameters["per_page"] = requestParameters["perPage"]
    }

    if (requestParameters["search"] != null) {
      queryParameters["search"] = requestParameters["search"]
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request(
      {
        path: `/api/v1/bookmarkings-without-bookmark/`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedBookmarkingListFromJSON(jsonValue))
  }

  /**
   * 북마크가 없는 북마킹들을 조회합니다.
   */
  async apiV1BookmarkingsWithoutBookmarkList(
    requestParameters: ApiV1BookmarkingsWithoutBookmarkListRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<PaginatedBookmarkingList> {
    const response = await this.apiV1BookmarkingsWithoutBookmarkListRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   */
  async apiV1BookmarksBookmarkingsListRaw(
    requestParameters: ApiV1BookmarksBookmarkingsListRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<PaginatedBookmarkingList>> {
    if (requestParameters["bookmarkPk"] == null) {
      throw new runtime.RequiredError(
        "bookmarkPk",
        'Required parameter "bookmarkPk" was null or undefined when calling apiV1BookmarksBookmarkingsList().'
      )
    }

    const queryParameters: any = {}

    if (requestParameters["ordering"] != null) {
      queryParameters["ordering"] = requestParameters["ordering"]
    }

    if (requestParameters["page"] != null) {
      queryParameters["page"] = requestParameters["page"]
    }

    if (requestParameters["perPage"] != null) {
      queryParameters["per_page"] = requestParameters["perPage"]
    }

    if (requestParameters["search"] != null) {
      queryParameters["search"] = requestParameters["search"]
    }

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request(
      {
        path: `/api/v1/bookmarks/{bookmark_pk}/bookmarkings/`.replace(
          `{${"bookmark_pk"}}`,
          encodeURIComponent(String(requestParameters["bookmarkPk"]))
        ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedBookmarkingListFromJSON(jsonValue))
  }

  /**
   */
  async apiV1BookmarksBookmarkingsList(
    requestParameters: ApiV1BookmarksBookmarkingsListRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<PaginatedBookmarkingList> {
    const response = await this.apiV1BookmarksBookmarkingsListRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   */
  async apiV1BookmarksBookmarkingsRetrieveRaw(
    requestParameters: ApiV1BookmarksBookmarkingsRetrieveRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<Bookmarking>> {
    if (requestParameters["bookmarkPk"] == null) {
      throw new runtime.RequiredError(
        "bookmarkPk",
        'Required parameter "bookmarkPk" was null or undefined when calling apiV1BookmarksBookmarkingsRetrieve().'
      )
    }

    if (requestParameters["id"] == null) {
      throw new runtime.RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling apiV1BookmarksBookmarkingsRetrieve().'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request(
      {
        path: `/api/v1/bookmarks/{bookmark_pk}/bookmarkings/{id}/`
          .replace(`{${"bookmark_pk"}}`, encodeURIComponent(String(requestParameters["bookmarkPk"])))
          .replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      },
      initOverrides
    )

    return new runtime.JSONApiResponse(response, (jsonValue) => BookmarkingFromJSON(jsonValue))
  }

  /**
   */
  async apiV1BookmarksBookmarkingsRetrieve(
    requestParameters: ApiV1BookmarksBookmarkingsRetrieveRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<Bookmarking> {
    const response = await this.apiV1BookmarksBookmarkingsRetrieveRaw(requestParameters, initOverrides)
    return await response.value()
  }

  /**
   * Removes the specified Bookmarking if it belongs to the current user. Returns 204 on success.
   * Delete a Bookmarking
   */
  async bookmarkingDeleteRaw(
    requestParameters: BookmarkingDeleteRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters["bookmarkingId"] == null) {
      throw new runtime.RequiredError(
        "bookmarkingId",
        'Required parameter "bookmarkingId" was null or undefined when calling bookmarkingDelete().'
      )
    }

    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request(
      {
        path: `/api/v1/bookmarkings/{bookmarking_id}`.replace(
          `{${"bookmarking_id"}}`,
          encodeURIComponent(String(requestParameters["bookmarkingId"]))
        ),
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters
      },
      initOverrides
    )

    return new runtime.VoidApiResponse(response)
  }

  /**
   * Removes the specified Bookmarking if it belongs to the current user. Returns 204 on success.
   * Delete a Bookmarking
   */
  async bookmarkingDelete(
    requestParameters: BookmarkingDeleteRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<void> {
    await this.bookmarkingDeleteRaw(requestParameters, initOverrides)
  }

  /**
   * 단일 밈과 여러 북마크에 대해서 동시에 다룹니다.
   * bulk sync bookmarkings
   */
  async bookmarkingSyncRaw(
    requestParameters: BookmarkingSyncOperationRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<runtime.ApiResponse<any>> {
    const queryParameters: any = {}

    const headerParameters: runtime.HTTPHeaders = {}

    headerParameters["Content-Type"] = "application/json"

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken
      const tokenString = await token("jwtHeaderAuth", [])

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`
      }
    }
    const response = await this.request(
      {
        path: `/api/v1/bookmarkings/`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: BookmarkingSyncRequestToJSON(requestParameters["bookmarkingSyncRequest"])
      },
      initOverrides
    )

    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new runtime.JSONApiResponse<any>(response)
    } else {
      return new runtime.TextApiResponse(response) as any
    }
  }

  /**
   * 단일 밈과 여러 북마크에 대해서 동시에 다룹니다.
   * bulk sync bookmarkings
   */
  async bookmarkingSync(
    requestParameters: BookmarkingSyncOperationRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction
  ): Promise<any> {
    const response = await this.bookmarkingSyncRaw(requestParameters, initOverrides)
    return await response.value()
  }
}
